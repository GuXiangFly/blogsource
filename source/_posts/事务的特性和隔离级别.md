---
title: 事务的特性和隔离级别
date: 2017-5-22 23:03:12
tags: [数据库]

---
## 事务的特性(ACID特性)

- A:**原子性(Atomicity)**
       表示事务内操作不可分割。要么都成功、要么都是失败。
- C:**一致性(Consistency)**
       要么都成功、要么都是失败.后面的失败了要对前面的操作进行回滚。
- I:**隔离性(Isolation)**
      多个用户并发访问数据库的时候，一个事务的执行不能被其他事务干扰。
- D:**持续性/永久性(Durability)**
      一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。


## 会引发的的问题
在数据库的事务特性中, 最重要的是隔离性,如果 多个事务共同同时操作 同一个表中数据时, 不考虑 隔离性,
那么就会引发非常严重的问题,  主要会有以下的三类问题:

- 第一类: **脏读(dirty read )**,  一个事务在操作的时候,读到了其他的事务未提交的数据, 这叫做脏读,也是最严重的
问题.
- 第二类: **不可重复读(unreatable read)**, 一个事务在操作的时候,读到的其他的事务已经提交的数据 , 主要指   （不可重复读的意思就是执行了语句后  提交和未提交 这两次读的数据不一样）
通过update 语句对数据库中现有的数据进行了更新操作
- 第三类: **虚读/幻读(phantom read)**, 一个事务在操作的时候,读到的其他的事务已经提交的数据, 主要值 使用
Insert 语句 插入了新的记录

## 四种隔离级别 
针对以上三类问题,数据库 提供了4 种 隔离级别, 用于解决以上三类问题.

- 第一种: read uncommitted (读 未提交), 会产生 脏读, 不可重复读, 虚读的发生是有概率的  
- 第二种: read committed(读已提交), 不会产生脏读, 但是会引发不可重复读.   虚读的发生是有概率的
- 第三种: repeatable read (可以重复读), 不会发生脏读, 不可重复读, 虚读发生是有概率的
- 第四种: serializable (串行化),  不会发生以上的三类问题.（串行化是指 两个窗口 同时对一组数据进行事务操作的时候  会冲突  只有一个窗口执行好后 再执行另一个窗口的操作）


对于 以上四种隔离级别,串行化解决了所有的问题, 但是效率是最低的, 实际开发中,最常用的是
第二种以及第三种隔离级别.
 
- Mysql: 默认的隔离级别是   **repeatable read**
- Oracle: 默认的隔离级别是  **read committed**
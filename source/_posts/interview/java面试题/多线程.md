# 1、Java线程有哪些状态？并画出状态转换图 

参考答案：

 

**解题思路：**基础知识
**考察点：**java 线程 
**分类：**java 线程 {校招，社招}
**难度分级：**P4，P5

## 2、举例Java线程安全的实现方法，原理、区别？

**参考答案：**

互斥同步：synchronized关键字 ， Lock  ReentrantLock，volatile
非阻塞同步：原子变量 atomicLong  原理：sun.misc.Unsafe类，CAS指令

**解题思路：**基础知识
**考察点：**java 线程 
**分类：**java 线程 {校招，社招}
**难度分级：**P4，P5

## 3、多次调用线程的start方法会怎么样？

 **参考答案：**
线程的start()只能被调用一次，否则会报java.lang.IllegalThreadStateException

**Thread类的start()方法** 展开原码

public synchronized void start() {

   if (threadStatus != 0)

​     throw new IllegalThreadStateException();

   ......

 }

**解题思路：**基础知识
**考察点：**java 线程 
**分类：**java 线程 {校招，社招}
**难度分级：**P4，P5

## 4、线程sleep()和yield()的区别是什么？

 **参考答案：** 

sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行_=82
sleep()可使优先级低的线程得到执行的机会，当然也可以让同优先级和高优先级的线程有执行的机会；yield()只能使同优先级的线程有执行的机会。

**解题思路：**基础知识
**考察点：**java 线程 
**分类：**java 线程 {校招，社招}
**难度分级：**P4，P5 

## 5、线程同步问题 

 **参考答案：**
1） 在需要同步的方法的方法签名中加入synchronized关键字。
2）使用synchronized块对需要进行同步的代码段进行同步。
3）使用JDK 5中提供的java.util.concurrent.lock包中的Lock对象。
4）锁的粒度：类级别和对象级别
5）读写锁,CountDownLatch等的使用
6) Lock与synchronized 的区别
http://houlinyan.iteye.com/blog/1112535

**解题思路：**基础知识
**考察点：**java 线程 
**分类：**java 线程 {校招，社招}
**难度分级：**P4，P5 

## 6、wait()和notify()，wait和sleep的区别  

**参考答案：**
wait()和notify()的区别： 
http://blog.csdn.net/oracle_microsoft/article/details/6863662
wait和sleep的区别：
（1）sleep是Thread类的方法，是线程用来 控制自身流程的，比如有一个要报时的线程，每一秒中打印出一个时间，那么我就需要在print方法前面加上一个sleep让自己每隔一秒执行一次。就像个闹钟一样。
wait是Object类的方法，用来线程间的通信，这个方法会使当前拥有该对象锁的进程等待知道其他线程调用notify方法时再醒来，不过你也可以给他指定一个时间，自动醒来。这个方法主要是用走不同线程之间的调度的。
（2）关于锁的释放 ，在这里假设大家已经知道了锁的概念及其意义。调用sleep方法不会释放锁（自己的感觉是sleep方法本来就是和锁没有关系的，因为他是一个线程用于管理自己的方法，不涉及线程通信）
（3）使用区域
由于wait函数的特殊意义，所以他是应该放在同步语句块中的，这样才有意义 。
注意：两个方法都需要抛出异常
**解题思路：**基础知识
**考察点：**
**分类：**{校招，社招}
**难度分级：**P4

## 7、IO密集型和CPU密集型与线程池大小的关系 

**参考答案：**

任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。
参考资料**：**http://www.infoq.com/cn/articles/java-threadPool

**解题思路：**基础知识
**考察点：**
**分类：**{校招，社招}
**难度分级：**P4，P5 

## 8、ThreadLocal 作用和实现机制 

 参考**答案：**

http://wowlinda80.iteye.com/blog/228600 

**解题思路：**基础知识
**考察点：**
**分类：**{校招，社招}
**难度分级：**P4，P5 

## 9、java线程池corePoolSize，maxPoolSize，queueCapacity这些参数的意义，如何考虑这些参数的设置

**参考答案：**
corePoolSize（线程池的基本大小）：核心线程数，核心线程会一直存活，即使没有任务需要处理。当线程数小于核心线程数时，即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理。
maximumPoolSize（线程池最大大小）：当线程数大于或等于核心线程，且任务队列已满时，线程池会创建新的线程，直到线程_=95_量达到maxPoolSize。如果线程数已等于maxPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池会拒绝处理任务而抛出异常。
queueCapacity(任务队列容量)：从maxPoolSize的描述上可以看出，任务队列的容量会影响到线程的变化，因此任务队列的长度也需要恰当的设置。

参数的设置参考http://blog.csdn.net/zhouhl_cn/article/details/7392607 
**解题思路：最好搞清楚线程池的主要处理流程。**
**考察点：线程池的理解与使用**
**分类：**{校招，社招}
**难度分级：**P4，P5 

## 10、ThreadLocal是什么，有什么典型的应用场景？

 **参考答案：**
http://wowlinda80.iteye.com/blog/228600

**解题思路：**最好搞清楚线程池的主要处理流程**。**
**考察点：**线程池的理解与使用
**分类：**{校招，社招}
**难度分级：**P4，P5  

## 11、考虑设计一个计数器程序，场景一，一个线程写，多个线程读；场景二，多个线程写，多个线程读。分别应对这2种场景设计一个计数器程序，要保证线程安全 

**参考答案：**
一写多读的情况主要需要考虑读到最新的数据，所以加volatile关键字即可
多写多读的情况就需要考虑原子操作，可以利用CAS原理
**解题思路：**基础知识
**考察点：**多线程，异步
**分类：**{校招，社招}
**难度分级：**P4，P5

## 12、多线程的使用场景，为了解决什么样的问题。不适用于什么场景 

**参考答案：**
这几点阐述的不完全正确
多线程优势
1.发挥多核处理器的强大能力，如果没有多核处理器，用多线程也只是形式而已，提升处理速度，常见的是一个任务用多线程跑比单线程跑快
2.建模简单，可以把一系列的复杂交互，变成简单的同步编程模型；比如我们在写controller时不用在考虑线程创建、销毁、调度优先级等；如果用单线程模型会变得非常复杂。
3.异步事件的简化处理，参见NIO的实现
多线程的风险
1.线程安全性
2.活跃性（死锁）问题
3.性能问题，频繁切换上下文，调度想要同时处理多件事：单线程处理不了的，必须使用多线程。（类似于分身术）
多个线程分解大任务：用单线程可以做，但是使用多线程可以更快。（类似于左右开弓）
可以引申到异步和多线程的区别上。
**解题思路：**基础知识
**考察点：**多线程，异步
**分类：**{校招，社招都可以用}
**难度分级：**P4，P5

##  13、线程池的实现原理

**参考答案：**

 线程池的作用是有效的降低频繁创建销毁线程所带来的额外开销。一般来说，线程池都是采用预创建的技术，在应用启动之初便预先创建一定数目的线程。应用在运行的过程中，需要时可以从这些线程所组成的线程池里申请分配一个空闲的线程，来执行一定的任务，任务完成后，并不是将线程销毁，而是将它返还给线程池，由线程池自行管理。如果线程池中预先分配的线程已经全部分配完毕，但此时又有新的任务请求，则线程池会动态的创建新的线程去适应这个请求。当然，有可能，某些时段应用并不需要执行很多的任务，导致了线程池中的线程大多处于空闲的状态，为了节省系统资源，线程池就需要动态的销毁其中的一部分空闲线程。因此，线程池都需要一个管理者，按照一定的要求去动态的维护其中线程的数目。线程池将频繁创建和销毁线程所带来的开销分摊到了每个具体执行的任务上，执行的次数越多，则分摊到每个任务上的开销就越小。当然，如果线程创建销毁所带来的开销与线程执行任务的开销相比微不足道，可以忽略不计，则线程池并没有使用的必要。

 这个例子不错：
 多线程就是通过线程调用线程实现的；打个比方来说就像“摆渡”，河的一岸有很多的人，他们想过河，过河的过程做什么就是他们自己的逻辑，只要他符合我的要求我就送你过河（线程池的要求就是实现Runnable或继承Thread类），然后我开了几条船去送人，只要河的这一岸有满足的人，我就送你过河。这个例子中河一岸的人就是我们要执行的任务，是一个集合，船就是线程池中的线程，由我们自己控制，过河这个动作就是要执行的逻辑，我们只负责把船调给你，怎么划桨怎么过河就是程序自己的逻辑了。 
**解题思路：**基础知识
**考察点：**线程池
**分类：**{校招，社招都可以用}
**难度分级：**P4，P5

##  14、常见的线程工具（同步器、线程安全集合类、原子类），什么场景下使用 

参考答案：

 [【java】【分享】java多线程](http://wiki.sankuai.com/pages/viewpage.action?pageId=79944720)
**解题思路：**基础知识
**考察点：**Java线程状态
**分类：**{校招，社招}
**难度分级：**P4

## 15、常见的线程状态，以及相互转换图；WAITING和BLOCK的区别 

**参考答案：**
线程状态以及相互转换图已有答案。
blocked是内部对象锁阻塞，另外blocked激活需要线程调度器允许其持有对象，waiting是等待其他线程通知线程调度器一个条件；
BLOCK产生的原因：I/O等待阻塞，suspend挂起等
WAITING产生原因：Thread.sleep，Object.wait等
**解题思路：**基础知识
**考察点：**Java线程状态
**分类：**{校招，社招}
**难度分级：**P4

## 16、常见的同步方式 synchronized 和 lock 如何选择 

**参考答案：**
参考：http://houlinyan.iteye.com/blog/1112535
**解题思路：**基础知识
**考察点：**线程同步方式
**分类：**{校招，社招}
**难度分级：**P4

## 17、死锁的几种场景，如何避免死锁  

**参考答案：**
**参考**http://www.cnblogs.com/cxd4321/archive/2012/05/28/2521542.html
**解题思路：**基础知识
**考察点：**死锁
**分类：**{校招，社招}
**难度分级：**P4

## 18、利用缓存机制优化一个复杂计算程序 

 展开原码

public class Memoizer<A, V> implements Computable<A, V> {

   private final ConcurrentMap<A, Future<V>> cache

​     = new ConcurrentHashMap<A, Future<V>>();

   private final Computable<A, V> c;

   public Memoizer(Computable<A, V> c) { this.c = c; }

   public V compute(final A arg) throws InterruptedException {

​     while (true) {

​       Future<V> f = cache.get(arg);

​       if (f == null) {

​         Callable<V> eval = new Callable<V>() {

​           public V call() throws InterruptedException {

​             return c.compute(arg);

​           }

​         };

​         FutureTask<V> ft = new FutureTask<V>(eval);

​         f = cache.putIfAbsent(arg, ft);

​         if (f == null) { f = ft; ft.run(); }

​       }

​       try {

​         return f.get();

​       } catch (CancellationException e) {

​         cache.remove(arg, f);

​       } catch (ExecutionException e) {

​         throw launderThrowable(e.getCause());

​       }

​     }

   } }

#  

## 19、Java方法体中用到了多线程，使用了ThreadPool，但是方法体内程序员没有显式调用ShutDown关闭线程池，那么该方法执行结束后，JVM是否能自动的关闭线程池，销毁线程？

标准答案：
答案是JVM不能自动关闭线程池，销毁线程。
可以参考海丰的[CRM每天第一次发布导致cpu load过高报警的问题](https://wiki.sankuai.com/:pages:viewpage.action%3FpageId=86358574) 
解题思路：基础知识
考察点：线程池
分类：{校招，社招都可以用}
难度分级：P4，P5 

##  20、ThreadPool中线程是如何做到重用的？

参考答案：
线程池在执行execute方法的时候，会根据初始化参数的大小以及线程池已有的线程数，来创建核心线程或者把task塞入任务队列；其中创建的核心线程创建后会启动，run方法内会执行一个runWork函数，此函数会不断地从任务队列中获取task执行。
解题思路：线程池的工作原理和工作流程。
考察点：线程池
分类：{校招，社招都可以用}
难度分级：P4，P5 
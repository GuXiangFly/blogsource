---
title: 深度学习
date: 2019-7-27 20:09:04
tags: [数据结构与算法]

---
## Numpy基础









## TensorFlow 基础学习

- 创建一张图包含了一组op和tensor

  - op： 只要使用TensorFlow的API定义的函数都是op

    - 下面的程序中 `tf.constant ` ,`tf.add` ,`tf.Variable` ，`tf.get_default_graph`这些都是op

    ```python
    import tensorflow as tf
    import os
    os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
    
    a = tf.constant(5.0)
    b = tf.constant(6.0)
    data2 = tf.Variable(10, name='var')
    sum1 = tf.add(a, b)
    
    # 定义一张图，相当于给程序分配一段内存
    graph = tf.get_default_graph()
    with tf.Session(graph=graph) as sess:
        print(sess.run(sum1))
    ```

    

  - 张量Tensor

    - 5.0 ，6.0  这些常量是张量

  - 变量

    - `10, name='var'` 这个就是变量

- graph 

  -  定义一张图，相当于给程序**分配一段内存**

- Session （会话）

  - tf.Session()
    运行TensorFlow操作图的类，使用默认注册的图（可以指定运行图）

  - 会话资源

    - 会话可能拥有很多资源，如 tf.Variable，tf.QueueBase和tf.ReaderBase，会话结束后需要进行资源释放

  - sess = tf.Session()    

    -  sess.run(...)      run是启动这个图，可以run多次

    - sess.close() 

      - 使用上下文管理器  运行完代码块后，会自己调用sess.close() 
        with tf.Session() as sess: 
        	sess.run(...)

    - 使用config=tf.ConfigProto(log_device_placement=True) 可以打印出在哪个CPU运行的
      ```python
      graph = tf.get_default_graph()
      with tf.Session(graph=graph, config=tf.ConfigProto(log_device_placement=True)) as sess:
          #print(sess.run(sum1))
          print（sum1.eval()）
      ```
      
    - 交互式：tf.InteractiveSession()



##### 重载运算符运行

- `sum2 = a + c ` 由于a 是张量， 执行程序的时候  c也会转为张量， +操作会转为tf.add(....)

```python
a = tf.constant(5.0)
b = tf.constant(6.0)
sum1 = tf.add(a, b)
c = 10.0

sum2 = a + c

# 定义一张图，相当于给程序分配一段内存
graph = tf.get_default_graph()
with tf.Session(graph=graph, config=tf.ConfigProto(log_device_placement=True)) as sess:
    print(sess.run(sum1))
    print(sess.run(sum2))
    print(sess.run([a, b, sum1, sum2]))
```



##### placeholder 占位符

- 意义：在程序执行的时候,不确定输入的是什么，提前“占个坑”
- 语法：placeholder提供占位符，run时候通过feed_dict指定参数

```python
import tensorflow as tf
import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
# 这个代表给的数据必须是两行三列的
tf.placeholder(tf.float32, [2, 3])
# 这个代表给的数据可以是不固定行数，三列的
plt = tf.placeholder(tf.float32, [None, 3])
# 定义一张图，相当于给程序分配一段内存
graph = tf.get_default_graph()
with tf.Session(graph=graph, config=tf.ConfigProto(log_device_placement=True)) as sess:
    print(sess.run(plt, feed_dict={plt: [
        [1, 2, 3],
        [2, 66, 3],
        [3, 4, 3],
        [1, 78, 3],
    ]}))
```



##### 张量

- 1、张量的阶和数据类型
  - tensor 是对 numpy的 ndarray 进行了封装
-  2、张量操作





```python

# tensorflow:打印出来的形状表示
# 0维：()   1维:(5)  2维：(5,6)   3维：(2,3,4)

# 形状的概念
# 静态形状和动态性状
# 对于静态形状来说，一旦张量形状固定了，不能再次设置静态形状, 不能夸维度修改 1D->1D 2D->2D
# 动态形状可以去创建一个新的张量,改变时候一定要注意元素数量要匹配  1D->2D  1->3D
#
 plt = tf.placeholder(tf.float32, [None, 2])
 print(plt)
 plt.set_shape([3, 2, 1])
 print(plt)
 # plt.set_shape([2, 3]) # 不能再次修改
 plt_reshape = tf.reshape(plt, [3, 3])
 print(plt_reshape)
 with tf.Session() as sess:
```



##### 变量

-  变量op

  - 1、变量op能够持久化保存，普通张量op是不行的

  - 2、当定义一个变量op的时候，一定要在会话当中去运行初始化

    - ```python
      init_op = tf.global_variables_initializer()
      
      with tf.Session() as sess:
        sess.run(init_op)
      ```

  - 3、name参数：在tensorboard使用的时候显示名字，可以让相同op名字的进行区分





#### TensorBoard

- **显示TensorBoard**

  数据序列化-events文件

  TensorBoard 通过读取 TensorFlow 的事件文件来运行。TensorFlow 的事件文件包括了你会在 TensorFlow 运行中涉及到的主要数据。事件文件的生成通过在程序中指定tf.summary.FileWriter存储的目录,以及要运行的图

  ```python
  tf.summary.FileWriter('/tmp/summary/test/', graph=default_graph)
  ```

- **启动TensorBoard**

  要运行TensorBoard，请使用以下命令

  ```
  tensorboard --logdir="path/to/log-directory"
  ```




##### TensorBoard 基础查看

![](https://i.loli.net/2020/04/17/FoSBqOTA4E9tgf7.png)





variable通过 random_normal 进行初始化，并且生成的是2x3的矩阵

![](https://i.loli.net/2020/04/17/CbOM1IxWHJLFUyG.png)

